<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Peek</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>
    (function () {
      try {
        const stored = localStorage.getItem("peek-theme");
        const theme = stored === "dark" ? "dark" : "light";
        if (theme === "dark") {
          document.documentElement.classList.add("dark");
        } else {
          document.documentElement.classList.remove("dark");
        }
        document.documentElement.dataset.theme = theme;
        document.documentElement.style.setProperty("color-scheme", theme === "dark" ? "dark" : "light");
      } catch (err) {
        console.warn("Unable to determine theme preference", err);
      }
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js" integrity="sha384-euuvJFcN7kYMZ8jr3vyz2hJfAl7YIXzt2M7vSFuk+r+LQ2Mbjsx8v6lS/gDliXL9" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/static/css/peek.css">

</head>
<body class="peek-body">
  <div class="peek-app">
    <header class="peek-header">
      <div class="peek-header-inner">
        <div class="peek-header-brand">
          <h1 class="peek-logo">Peek</h1>
          <p class="peek-tagline">Monitor every stream from one elegant dashboard.</p>
        </div>
        <div class="peek-header-actions">
          <button id="viewToggle" type="button" class="peek-toggle peek-toggle--pill">
            <span id="viewToggleLabel">Toggle layout</span>
          </button>
          <button id="themeToggle" type="button" class="peek-toggle peek-toggle--icon">
            <span id="themeToggleLabel" class="sr-only">Toggle theme</span>
            <span aria-hidden="true" class="peek-theme-icon">
              <svg data-theme-icon="sun" class="peek-theme-icon__glyph" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="1.5"></circle>
                <path d="M12 3.25v1.5M12 19.25v1.5M4.75 12h-1.5M20.75 12h-1.5M6.17 6.17l-1.06-1.06M18.89 18.89l-1.06-1.06M6.17 17.83l-1.06 1.06M18.89 5.11l-1.06 1.06" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path>
              </svg>
              <svg data-theme-icon="moon" class="peek-theme-icon__glyph hidden" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
              </svg>
            </span>
          </button>
        </div>
      </div>
    </header>

    <main class="peek-main">
      <div class="peek-main-inner">
        <aside class="peek-sidebar">
          <div class="peek-aside">
            <h2 class="peek-section-title">Configurations</h2>
            <div id="configList" class="peek-config-list" role="group" aria-label="Available configurations"></div>
            <p id="noConfigsMessage" class="peek-config-empty peek-empty hidden">
              No configurations are currently available. Add a config to begin streaming updates.
            </p>
          </div>
        </aside>
        <section class="peek-content">
            <div class="peek-panel peek-panel--main">
            <div class="peek-panel-header">
              <h2 id="activeConfigTitle" class="peek-panel-title">All configurations</h2>
              <p id="activeConfigSubtitle" class="peek-panel-subtitle">Showing the latest entries across every configuration.</p>
            </div>
            <div id="emptyState" class="peek-empty-state peek-empty hidden">
              <h3 class="peek-empty-title">No entries yet</h3>
              <p class="peek-empty-body">New items matching your filters will appear here automatically.</p>
            </div>
            <div id="itemsContainer" data-view-mode="list" class="peek-items peek-items--list"></div>
            <div id="loading" class="peek-loading hidden">
              <span class="peek-loading__dot"></span>
              Loading…
            </div>
            <div id="loadMoreSentinel" class="peek-load-more"></div>
          </div>
        </section>
      </div>
    </main>
  </div>

  <dialog id="detailDialog" class="peek-dialog">
    <div class="peek-dialog-header">
      <h3 class="peek-dialog-title">Item details</h3>
      <button id="closeDialog" type="button" class="peek-toggle peek-toggle--small">Close</button>
    </div>
    <pre id="detailJson" class="peek-dialog-json"></pre>
  </dialog>

  <script>
    const configs = {{ configs_json | safe }};
    const configListEl = document.getElementById("configList");
    const noConfigsMessage = document.getElementById("noConfigsMessage");
    const itemsContainer = document.getElementById("itemsContainer");
    const loadingEl = document.getElementById("loading");
    const loadMoreSentinel = document.getElementById("loadMoreSentinel");
    const emptyStateEl = document.getElementById("emptyState");
    const emptyStateBody = emptyStateEl ? emptyStateEl.querySelector(".peek-empty-body") : null;
    const activeConfigTitle = document.getElementById("activeConfigTitle");
    const activeConfigSubtitle = document.getElementById("activeConfigSubtitle");
    const detailDialog = document.getElementById("detailDialog");
    const detailJson = document.getElementById("detailJson");
    const closeDialog = document.getElementById("closeDialog");
    const viewToggle = document.getElementById("viewToggle");
    const viewToggleLabel = document.getElementById("viewToggleLabel");
    const themeToggle = document.getElementById("themeToggle");
    const themeToggleLabel = document.getElementById("themeToggleLabel");
    const themeIconSun = themeToggle ? themeToggle.querySelector('[data-theme-icon="sun"]') : null;
    const themeIconMoon = themeToggle ? themeToggle.querySelector('[data-theme-icon="moon"]') : null;

    const markdownItFactory = window.markdownit;
    const md = typeof markdownItFactory === "function" ? markdownItFactory({ html: false, linkify: true, breaks: true }) : null;
    if (!md) {
      console.warn("Markdown-it not available; falling back to plain text descriptions.");
    }

    const configDisplayNameBySlug = new Map(configs.map((config) => [config.slug, config.display_name]));
    const selectedSlugs = new Set();
    const state = {
      items: [],
      nextCursor: null,
      fetching: false,
      initialized: false
    };
    const itemById = new Map();
    let visibleItems = [];
    let eventSource = null;
    let reconnectTimeout = null;
    let viewMode = "list";

    try {
      const storedView = localStorage.getItem("peek-view-mode");
      if (storedView === "list" || storedView === "card") {
        viewMode = storedView;
      }
    } catch (err) {
      console.warn("Unable to load view preference", err);
    }

    function applyTheme(theme) {
      const wantsDark = theme === "dark";
      document.documentElement.classList.toggle("dark", wantsDark);
      document.documentElement.dataset.theme = wantsDark ? "dark" : "light";
      document.documentElement.style.setProperty("color-scheme", wantsDark ? "dark" : "light");
      if (document.body) {
        document.body.classList.toggle("dark", wantsDark);
      }
      const nextThemeLabel = wantsDark ? "Switch to light theme" : "Switch to dark theme";
      if (themeToggleLabel) {
        themeToggleLabel.textContent = nextThemeLabel;
      }
      if (themeToggle) {
        themeToggle.setAttribute("aria-label", nextThemeLabel);
        themeToggle.setAttribute("title", nextThemeLabel);
        themeToggle.setAttribute("aria-pressed", wantsDark ? "true" : "false");
      }
      if (themeIconSun && themeIconMoon) {
        themeIconSun.classList.toggle("hidden", wantsDark);
        themeIconMoon.classList.toggle("hidden", !wantsDark);
      }
      try {
        localStorage.setItem("peek-theme", wantsDark ? "dark" : "light");
      } catch (err) {
        console.warn("Unable to persist theme preference", err);
      }
    }

    function initThemeButton() {
      let initialTheme = "dark";
      try {
        const storedTheme = localStorage.getItem("peek-theme");
        if (storedTheme === "dark" || storedTheme === "light") {
          initialTheme = storedTheme;
        }
      } catch (err) {
        console.warn("Unable to read stored theme preference", err);
      }
      applyTheme(initialTheme);
      if (!themeToggle) {
        return;
      }
      themeToggle.addEventListener("click", () => {
        const next = document.documentElement.classList.contains("dark") ? "light" : "dark";
        applyTheme(next);
      });
    }

    function applyViewMode(mode) {
      viewMode = mode === "card" ? "card" : "list";
      itemsContainer.dataset.viewMode = viewMode;
      itemsContainer.className = viewMode === "card"
        ? "peek-items peek-items--grid"
        : "peek-items peek-items--list";
      if (viewToggle) {
        viewToggle.setAttribute("aria-pressed", viewMode === "card" ? "true" : "false");
      }
      const nextViewLabel = viewMode === "card" ? "Switch to list view" : "Switch to card view";
      if (viewToggleLabel) {
        viewToggleLabel.textContent = nextViewLabel;
      }
      if (viewToggle) {
        viewToggle.setAttribute("aria-label", nextViewLabel);
      }
      try {
        localStorage.setItem("peek-view-mode", viewMode);
      } catch (err) {
        console.warn("Unable to store view preference", err);
      }
      renderItems();
    }

    if (viewToggle) {
      viewToggle.addEventListener("click", () => {
        const next = viewMode === "card" ? "list" : "card";
        applyViewMode(next);
      });
    }

    initThemeButton();
    applyViewMode(viewMode);

    function safeHref(url) {
      if (typeof url !== "string" || url.trim().length === 0) return null;
      try {
        const parsed = new URL(url, window.location.origin);
        if (parsed.protocol === "http:" || parsed.protocol === "https:") {
          return parsed.href;
        }
        return null;
      } catch (err) {
        return null;
      }
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function renderDescription(markdownText) {
      if (typeof markdownText !== "string" || !markdownText.trim()) {
        return "";
      }
      if (md) {
        return md.render(markdownText);
      }
      const escaped = escapeHtml(markdownText);
      return escaped.replace(/\\n/g, "<br />");
    }

    function formatTimestamp(value) {
      if (typeof value !== "string") return "";
      try {
        const date = new Date(value);
        if (Number.isNaN(date.valueOf())) return value;
        return new Intl.DateTimeFormat(undefined, {
          dateStyle: "medium",
          timeStyle: "short"
        }).format(date);
      } catch (err) {
        return value;
      }
    }

    function resolveConfigSlug(slug) {
      if (typeof slug !== "string" || slug.trim() === "") {
        return "Unknown configuration";
      }
      return configDisplayNameBySlug.get(slug) || slug;
    }

    function resolveConfigName(item) {
      if (!item) {
        return "Unknown configuration";
      }
      if (typeof item.config_display_name === "string" && item.config_display_name.trim()) {
        return item.config_display_name;
      }
      return resolveConfigSlug(item.config);
    }

    function computeCounts() {
      const counts = new Map();
      state.items.forEach((item) => {
        const slug = item?.config;
        if (!slug) {
          return;
        }
        counts.set(slug, (counts.get(slug) || 0) + 1);
      });
      return counts;
    }

    function toggleConfig(slug) {
      if (selectedSlugs.has(slug)) {
        selectedSlugs.delete(slug);
      } else {
        selectedSlugs.add(slug);
      }
      renderConfigList();
      renderItems();
      updateActiveMeta();
    }

    function getFilteredItems() {
      if (!configs.length || selectedSlugs.size === 0 || selectedSlugs.size === configs.length) {
        return state.items.slice();
      }
      return state.items.filter((item) => selectedSlugs.has(item.config));
    }

    function renderConfigList() {
      configListEl.innerHTML = "";
      if (!configs.length) {
        noConfigsMessage.classList.remove("hidden");
        return;
      }
      noConfigsMessage.classList.add("hidden");

      const counts = computeCounts();
      configs.forEach((config) => {
        const isSelected = selectedSlugs.has(config.slug);
        const button = document.createElement("button");
        button.type = "button";
        const baseClasses = ["peek-config-button"];
        if (isSelected) {
          baseClasses.push("peek-config-button-active");
        }
        button.className = baseClasses.join(" ");
        button.setAttribute("role", "checkbox");
        button.setAttribute("aria-checked", isSelected ? "true" : "false");
        button.setAttribute("data-slug", config.slug);
        const count = counts.get(config.slug) || 0;
        button.innerHTML = `
          <span class="peek-config-button__meta">
            <span class="peek-config-button__name">${escapeHtml(config.display_name)}</span>
            <span class="peek-config-button__slug">${escapeHtml(config.slug)}</span>
          </span>
          <span class="peek-config-button__status">${count} entr${count === 1 ? "y" : "ies"}</span>
        `;
        button.addEventListener("click", () => {
          toggleConfig(config.slug);
        });
        configListEl.appendChild(button);
      });
    }

    function renderItems() {
      visibleItems = getFilteredItems();
      itemsContainer.innerHTML = "";

      if (!state.initialized) {
        emptyStateEl.classList.add("hidden");
        return;
      }

      if (!visibleItems.length) {
        if (!configs.length) {
          if (emptyStateBody) {
            emptyStateBody.textContent = "Add a configuration to begin ingesting data.";
          }
        } else if (selectedSlugs.size > 0 && state.items.length) {
          if (emptyStateBody) {
            emptyStateBody.textContent = "No entries match the selected configurations yet.";
          }
        } else if (emptyStateBody) {
          emptyStateBody.textContent = "New items will appear here automatically.";
        }
        emptyStateEl.classList.remove("hidden");
        return;
      }

      emptyStateEl.classList.add("hidden");

      if (viewMode === "card") {
        visibleItems.forEach((item) => {
          const article = document.createElement("article");
          article.className = "peek-item peek-item--card";
          if (item?.config) {
            article.dataset.config = item.config;
          }

          const highlights = Array.isArray(item?.view?.highlights) ? item.view.highlights : [];
          highlights.forEach((highlight) => {
            article.classList.add(highlight);
          });

          const header = document.createElement("div");
          header.className = "peek-item-header";

          if (item?.view?.badge) {
            const badge = document.createElement("span");
            badge.className = "peek-item-badge";
            badge.textContent = item.view.badge;
            header.appendChild(badge);
          }

          const title = document.createElement("h3");
          title.className = "peek-item-title";
          title.textContent = item?.view?.title || "Untitled entry";
          header.appendChild(title);

          const linkHref = safeHref(item?.view?.link);
          if (linkHref) {
            const link = document.createElement("a");
            link.href = linkHref;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.className = "peek-item-link";
            link.textContent = "Open link";
            link.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            header.appendChild(link);
          }

          const configLabel = document.createElement("span");
          configLabel.className = "peek-item-config";
          configLabel.textContent = resolveConfigName(item);
          header.appendChild(configLabel);

          const timestamp = document.createElement("time");
          timestamp.className = "peek-item-timestamp";
          timestamp.dateTime = item.ts || "";
          timestamp.textContent = formatTimestamp(item.ts);
          header.appendChild(timestamp);

          const description = document.createElement("div");
          description.className = "peek-item-description peek-markdown";
          description.innerHTML = renderDescription(item?.view?.description || "");

          const footer = document.createElement("div");
          footer.className = "peek-item-footer";

          const detailButton = document.createElement("button");
          detailButton.type = "button";
          detailButton.className = "peek-toggle peek-toggle--small";
          detailButton.textContent = "View details";
          detailButton.addEventListener("click", (event) => {
            event.stopPropagation();
            openDetail(item);
          });

          footer.appendChild(detailButton);

          article.appendChild(header);
          if (description.innerHTML.trim()) {
            article.appendChild(description);
          }
          article.appendChild(footer);

          article.addEventListener("click", () => {
            openDetail(item);
          });

          itemsContainer.appendChild(article);
        });
        return;
      }

      const frame = document.createElement("div");
      frame.className = "peek-table-wrapper peek-panel";
      const scroll = document.createElement("div");
      scroll.className = "peek-table-scroll";
      const table = document.createElement("table");
      table.className = "peek-table";
      const colGroup = document.createElement("colgroup");
      ["18%", "26%", "32%", "12%", "8%", "4%"].forEach((width) => {
        const col = document.createElement("col");
        col.style.width = width;
        colGroup.appendChild(col);
      });
      table.appendChild(colGroup);
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      const headerLabels = ["Configuration", "Title", "Description", "Link", "Timestamp", "Actions"];
      headerLabels.forEach((label, index) => {
        const th = document.createElement("th");
        th.scope = "col";
        th.textContent = label;
        if (index === headerLabels.length - 1) {
          th.className = "peek-table-heading--right";
        }
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      visibleItems.forEach((item) => {
        const tr = document.createElement("tr");
        tr.className = "peek-table-row";
        if (item?.config) {
          tr.dataset.config = item.config;
        }
        const highlights = Array.isArray(item?.view?.highlights) ? item.view.highlights : [];
        highlights.forEach((highlight) => {
          tr.classList.add(highlight);
        });
        tr.addEventListener("click", () => {
          openDetail(item);
        });

        const configCell = document.createElement("td");
        configCell.className = "peek-table-cell peek-table-cell--config";
        configCell.textContent = resolveConfigName(item);
        tr.appendChild(configCell);

        const titleCell = document.createElement("td");
        titleCell.className = "peek-table-cell peek-table-cell--title";
        const titleLayout = document.createElement("div");
        titleLayout.className = "peek-table-title";
        if (item?.view?.badge) {
          const badge = document.createElement("span");
          badge.className = "peek-item-badge peek-item-badge--compact";
          badge.textContent = item.view.badge;
          titleLayout.appendChild(badge);
        }
        const titleText = document.createElement("span");
        titleText.className = "peek-table-title-text";
        titleText.textContent = item?.view?.title || "Untitled entry";
        titleLayout.appendChild(titleText);
        titleCell.appendChild(titleLayout);

        const descriptionCell = document.createElement("td");
        descriptionCell.className = "peek-table-cell peek-table-cell--description";
        const descriptionContent = document.createElement("div");
        descriptionContent.className = "peek-markdown peek-table-description";
        const renderedDescription = renderDescription(item?.view?.description || "");
        if (renderedDescription.trim()) {
          descriptionContent.innerHTML = renderedDescription;
        } else {
          descriptionContent.innerHTML = '<span class="peek-table-placeholder">—</span>';
        }
        descriptionCell.appendChild(descriptionContent);

        const linkCell = document.createElement("td");
        linkCell.className = "peek-table-cell";
        const linkHref = safeHref(item?.view?.link);
        if (linkHref) {
          const link = document.createElement("a");
          link.href = linkHref;
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          link.className = "peek-item-link peek-item-link--table";
          link.textContent = "Open link";
          link.addEventListener("click", (event) => {
            event.stopPropagation();
          });
          linkCell.appendChild(link);
        } else {
          const noLink = document.createElement("span");
          noLink.className = "peek-table-placeholder";
          noLink.textContent = "—";
          linkCell.appendChild(noLink);
        }

        const timestampCell = document.createElement("td");
        timestampCell.className = "peek-table-cell peek-table-cell--timestamp";
        const timestamp = document.createElement("time");
        timestamp.dateTime = item.ts || "";
        timestamp.textContent = formatTimestamp(item.ts);
        timestampCell.appendChild(timestamp);

        const actionCell = document.createElement("td");
        actionCell.className = "peek-table-cell peek-table-cell--actions";
        const detailButton = document.createElement("button");
        detailButton.type = "button";
        detailButton.className = "peek-toggle peek-toggle--tiny";
        detailButton.textContent = "Details";
        detailButton.addEventListener("click", (event) => {
          event.stopPropagation();
          openDetail(item);
        });
        actionCell.appendChild(detailButton);

        tr.appendChild(titleCell);
        tr.appendChild(descriptionCell);
        tr.appendChild(linkCell);
        tr.appendChild(timestampCell);
        tr.appendChild(actionCell);

        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      scroll.appendChild(table);
      frame.appendChild(scroll);
      itemsContainer.appendChild(frame);
    }

    function openDetail(item) {
      if (!detailDialog) {
        return;
      }
      if (detailJson) {
        detailJson.textContent = JSON.stringify(item, null, 2);
      }
      if (typeof detailDialog.showModal === "function") {
        detailDialog.showModal();
      }
    }

    if (closeDialog && detailDialog) {
      closeDialog.addEventListener("click", () => {
        if (typeof detailDialog.close === "function") {
          detailDialog.close();
        }
      });
    }

    function updateActiveMeta() {
      if (!activeConfigTitle || !activeConfigSubtitle) {
        return;
      }

      if (!configs.length) {
        activeConfigTitle.textContent = "No configurations available";
        activeConfigSubtitle.textContent = "Add a configuration to begin ingesting data.";
        return;
      }

      if (!state.initialized) {
        activeConfigTitle.textContent = "All configurations";
        activeConfigSubtitle.textContent = "Loading the latest activity…";
        return;
      }

      const totalItems = state.items.length;
      const visibleCount = visibleItems.length;
      const totalConfigs = configs.length;

      if (selectedSlugs.size === 0 || selectedSlugs.size === totalConfigs) {
        activeConfigTitle.textContent = "All configurations";
        activeConfigSubtitle.textContent = totalItems
          ? `${totalItems} entr${totalItems === 1 ? "y" : "ies"} loaded across ${totalConfigs} configuration${totalConfigs === 1 ? "" : "s"}.`
          : "Listening for new activity across every configuration…";
        return;
      }

      const selectedNames = configs
        .filter((config) => selectedSlugs.has(config.slug))
        .map((config) => config.display_name);

      activeConfigTitle.textContent = selectedNames.join(", ");
      activeConfigSubtitle.textContent = visibleCount
        ? `${visibleCount} entr${visibleCount === 1 ? "y" : "ies"} from ${selectedSlugs.size} selected configuration${selectedSlugs.size === 1 ? "" : "s"}.`
        : "Listening for new activity from the selected configurations…";
    }

    function updateLoading(isLoading) {
      loadingEl.classList.toggle("hidden", !isLoading);
    }

    const observer = new IntersectionObserver((entries) => {
      if (!state.nextCursor || state.fetching) {
        return;
      }
      if (entries.some((entry) => entry.isIntersecting)) {
        fetchItems({ append: true });
      }
    });

    if (loadMoreSentinel) {
      observer.observe(loadMoreSentinel);
    }

    async function fetchItems({ append = false, cursorOverride = null } = {}) {
      if (state.fetching) {
        return;
      }
      const cursorToUse = cursorOverride ?? (append ? state.nextCursor : null);
      if (append && !cursorToUse) {
        return;
      }
      state.fetching = true;
      updateLoading(true);

      const params = new URLSearchParams({ limit: "50" });
      if (cursorToUse) {
        params.set("cursor", cursorToUse);
      }

      try {
        const response = await fetch(`/api/items?${params.toString()}`);
        if (!response.ok) {
          throw new Error(`Failed to load items: ${response.status}`);
        }
        const payload = await response.json();
        const items = Array.isArray(payload.items) ? payload.items : [];
        items.forEach((item) => {
          if (!item || !item.id) {
            return;
          }
          itemById.set(item.id, item);
        });
        state.items = Array.from(itemById.values());
        state.items.sort((a, b) => (a.ts < b.ts ? 1 : -1));
        while (state.items.length > 500) {
          const removed = state.items.pop();
          if (removed && removed.id) {
            itemById.delete(removed.id);
          }
        }
        state.nextCursor = payload.next_cursor || null;
        state.initialized = true;
        renderConfigList();
        renderItems();
      } catch (err) {
        console.error(err);
      } finally {
        state.fetching = false;
        updateLoading(false);
        updateActiveMeta();
      }
    }

    function upsertItem(item) {
      if (!item || !item.id) {
        return;
      }
      itemById.set(item.id, item);
      state.items = Array.from(itemById.values());
      state.items.sort((a, b) => (a.ts < b.ts ? 1 : -1));
      while (state.items.length > 500) {
        const removed = state.items.pop();
        if (removed && removed.id) {
          itemById.delete(removed.id);
        }
      }
      state.initialized = true;
    }

    function connectStream() {
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      try {
        eventSource = new EventSource("/api/stream");
      } catch (err) {
        console.error("Failed to connect to stream", err);
        return;
      }
      eventSource.addEventListener("message", (event) => {
        try {
          const item = JSON.parse(event.data);
          upsertItem(item);
          renderConfigList();
          renderItems();
          updateActiveMeta();
        } catch (err) {
          console.error("Unable to parse stream payload", err);
        }
      });
      eventSource.addEventListener("error", () => {
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
        reconnectTimeout = window.setTimeout(() => {
          connectStream();
        }, 3000);
      });
    }

    renderConfigList();
    renderItems();
    updateActiveMeta();
    fetchItems();
    connectStream();

    window.addEventListener("beforeunload", () => {
      if (eventSource) {
        eventSource.close();
      }
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
      }
    });
  </script>
</body>
</html>
