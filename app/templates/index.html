<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Peek</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>
    (function () {
      try {
        const theme = localStorage.getItem("peek-theme") === "dark" ? "dark" : "light";
        if (theme === "dark") {
          document.documentElement.classList.add("dark");
        } else {
          document.documentElement.classList.remove("dark");
        }
        document.documentElement.dataset.theme = theme;
        document.documentElement.setAttribute("data-bs-theme", theme);
        document.documentElement.style.setProperty("color-scheme", theme === "dark" ? "dark" : "light");
      } catch (err) {
        console.warn("Unable to determine theme preference", err);
      }
    })();
  </script>
  <link rel="stylesheet" href="/static/css/bootstrap.min.css"><!-- 5.3.8 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
  <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/static/css/peek.css">
</head>
<body class="peek-body d-flex flex-column min-vh-100">
  <nav class="navbar navbar-expand-lg border-bottom bg-body-tertiary">
    <div class="container-fluid container-xxl py-3">
      <div class="d-flex align-items-center w-100 gap-3">
        <a class="navbar-brand fw-semibold fs-3 mb-0" href="#" aria-label="Peek dashboard home">Peek</a>
        <button class="navbar-toggler ms-auto" type="button" data-bs-toggle="collapse" data-bs-target="#peekNavbar" aria-controls="peekNavbar" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
      </div>
      <div class="collapse navbar-collapse mt-3 mt-lg-0" id="peekNavbar">
        <div class="d-flex flex-column flex-lg-row align-items-stretch align-items-lg-center gap-3 ms-lg-auto w-100 w-lg-auto">
          <div class="d-flex flex-row gap-2">
            <button class="btn btn-outline-secondary" type="button" data-bs-toggle="offcanvas" data-bs-target="#configOffcanvas" aria-controls="configOffcanvas">
              <i class="bi bi-filter"></i>
            </button>
            <button id="viewToggle" type="button" class="btn btn-outline-secondary d-inline-flex align-items-center justify-content-center">
			  <span id="viewToggleLabel" class="visually-hidden">Toggle view, list or card</span>
              <i data-view-icon="list" class="bi bi-list"></i>
			  <i data-view-icon="card" class="bi bi-card-list"></i>
            </button>
          <button id="themeToggle" type="button" class="btn btn-outline-secondary d-inline-flex align-items-center justify-content-center">
            <span id="themeToggleLabel" class="visually-hidden">Toggle theme</span>
              <i data-theme-icon="sun" class="bi bi-sun"></i>
			  <i data-theme-icon="moon" class="bi bi-moon"></i>
          </button>
		  </div>
        </div>
      </div>
    </div>
  </nav>

  <main class="flex-grow-1 py-4">
    <div class="container-fluid container-xxl">
      <section class="row gy-4">
        <div class="col-12">
          <div class="card border-0 shadow-sm peek-panel">
            <div class="card-body p-4">
              <div class="d-flex flex-column flex-md-row align-items-md-center justify-content-between gap-3">
                <div>
                  <h1 id="activeConfigTitle" class="h4 mb-1">All configurations</h1>
                  <p id="activeConfigSubtitle" class="text-body-secondary mb-0">Showing the latest entries across every configuration.</p>
                </div>
                <div class="text-md-end">
                  <span class="badge rounded-pill text-bg-primary" id="itemsCountBadge" hidden>0 items</span>
                </div>
              </div>
              <div id="emptyState" class="alert alert-info text-center mt-4 hidden" role="status">
                <h2 class="h5 mb-2">No entries yet</h2>
                <p id="emptyStateMessage" class="mb-0">New items matching your filters will appear here automatically.</p>
              </div>
              <div id="itemsContainer" class="peek-items mt-4" data-view-mode="list"></div>
              <div id="loading" class="d-flex justify-content-center align-items-center gap-2 py-4 hidden">
                <div class="spinner-border" role="status" aria-hidden="true"></div>
                <span>Loading…</span>
              </div>
              <div id="loadMoreSentinel" class="load-more-sentinel"></div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <div class="offcanvas offcanvas-end" tabindex="-1" id="configOffcanvas" aria-labelledby="configOffcanvasLabel">
    <div class="offcanvas-header">
      <h2 class="offcanvas-title h5 mb-0" id="configOffcanvasLabel">Streams</h2>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body d-flex flex-column gap-3">
      <p class="text-body-secondary small mb-0">Toggle configurations to refine the timeline. Everything is shown when no filters are active.</p>
      <div id="configList" class="list-group gap-2" role="group" aria-label="Available configurations"></div>
      <p id="noConfigsMessage" class="text-center text-body-secondary small hidden mb-0">
        No configurations are currently available. Add a config to begin streaming updates.
      </p>
    </div>
  </div>

  <dialog id="detailDialog" class="peek-dialog rounded-4 shadow-lg">
    <div class="peek-dialog-header d-flex align-items-center justify-content-between">
      <h3 class="peek-dialog-title h5 mb-0">Item details</h3>
      <button id="closeDialog" type="button" class="btn btn-outline-secondary btn-sm">Close</button>
    </div>
    <pre id="detailJson" class="peek-dialog-json rounded-3 mt-3 mb-0"></pre>
  </dialog>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    const configs = {{ configs_json | safe }};
    const configListEl = document.getElementById("configList");
    const noConfigsMessage = document.getElementById("noConfigsMessage");
    const itemsContainer = document.getElementById("itemsContainer");
    const loadingEl = document.getElementById("loading");
    const loadMoreSentinel = document.getElementById("loadMoreSentinel");
    const emptyStateEl = document.getElementById("emptyState");
    const emptyStateMessageEl = document.getElementById("emptyStateMessage");
    const viewToggle = document.getElementById("viewToggle");
    const themeToggle = document.getElementById("themeToggle");
    const detailDialog = document.getElementById("detailDialog");
    const closeDialog = document.getElementById("closeDialog");
    const detailJson = document.getElementById("detailJson");
    const activeConfigTitle = document.getElementById("activeConfigTitle");
    const activeConfigSubtitle = document.getElementById("activeConfigSubtitle");
    const itemsCountBadge = document.getElementById("itemsCountBadge");
    const themeIconSun = document.querySelector('[data-theme-icon="sun"]');
    const themeIconMoon = document.querySelector('[data-theme-icon="moon"]');
	const viewIconCard = document.querySelector('[data-view-icon="card"]');
	const viewIconList = document.querySelector('[data-view-icon="list"]');
	const view = localStorage.getItem("peek-view") === "list" ? "list" : "card";

    let markdownParser;
    try {
      markdownParser = window.markdownit({
        breaks: true,
        linkify: true,
      });
    } catch (err) {
      console.warn("Failed to load markdown-it", err);
      markdownParser = null;
    }

    const itemById = new Map();
    const selectedSlugs = new Set();
    const state = {
      viewMode: view,
      fetching: false,
      cursor: null,
      nextCursor: null,
      items: [],
      initialized: false,
      countByConfig: new Map(),
    };
    let eventSource = null;
    let reconnectTimeout = null;
    let visibleItems = [];
    const pendingDismissals = new Set();

    const listGroupBaseClass = "list-group-item list-group-item-action d-flex flex-column flex-sm-row align-items-start align-items-sm-center justify-content-between gap-2 rounded-3 peek-config-button";
    const listGroupActiveClass = "active";

    function escapeHtml(html) {
      const span = document.createElement("span");
      span.textContent = html ?? "";
      return span.innerHTML;
    }

    function safeHref(href) {
      if (typeof href !== "string" || !href.trim()) {
        return null;
      }
      const trimmed = href.trim();
      if (/^https?:\/\//i.test(trimmed) || trimmed.startsWith("/")) {
        return trimmed;
      }
      return null;
    }

    function renderDescription(value) {
      if (!value) {
        return "";
      }
      if (markdownParser) {
        try {
          return markdownParser.render(value);
        } catch (err) {
          console.warn("Unable to render markdown", err);
        }
      }
      return escapeHtml(value);
    }

    function formatTimestamp(ts) {
      if (!ts) {
        return "Unknown time";
      }
      try {
        const parsed = new Date(ts);
        if (Number.isNaN(parsed.getTime())) {
          return "Unknown time";
        }
        const relativeFormatter = new Intl.RelativeTimeFormat(undefined, { numeric: "auto" });
        const now = Date.now();
        const diffMs = parsed.getTime() - now;
        const diffMinutes = Math.round(diffMs / 60000);
        if (Math.abs(diffMinutes) < 60) {
          return relativeFormatter.format(diffMinutes, "minute");
        }
        const diffHours = Math.round(diffMs / 3600000);
        if (Math.abs(diffHours) < 24) {
          return relativeFormatter.format(diffHours, "hour");
        }
        return parsed.toLocaleString();
      } catch (err) {
        return ts;
      }
    }

    function resolveConfigName(item) {
      if (!item || !configs.length) {
        return "";
      }
      const config = configs.find((candidate) => candidate.slug === item.config);
      return config?.display_name || item.config || "";
    }

    function updateLoading(show) {
      if (!loadingEl) {
        return;
      }
      loadingEl.classList.toggle("hidden", !show);
    }

    function syncViewToggleState() {
      if (viewToggle) {
        viewToggle.setAttribute("aria-pressed", state.viewMode === "card" ? "true" : "false");
        viewToggle.dataset.viewMode = state.viewMode;
      }
        //const next = state.viewMode === "list" ? "Switch to cards" : "Switch to table";
        //viewToggleLabel.textContent = next;
	  if (state.viewMode === "list") {
		viewIconCard?.classList.add("hidden");
		viewIconList?.classList.remove("hidden");
	  } else {
		viewIconCard?.classList.remove("hidden");
		viewIconList?.classList.add("hidden");
	  }
    }

    function updateThemeIcons(nextTheme) {
      if (nextTheme === "dark") {
        themeIconSun?.classList.add("hidden");
        themeIconMoon?.classList.remove("hidden");
      } else {
        themeIconSun?.classList.remove("hidden");
        themeIconMoon?.classList.add("hidden");
      }
    }

    function toggleTheme() {
      const current = document.documentElement.dataset.theme === "dark" ? "dark" : "light";
      const next = current === "dark" ? "light" : "dark";
      document.documentElement.dataset.theme = next;
      document.documentElement.style.setProperty("color-scheme", next === "dark" ? "dark" : "light");
      document.documentElement.setAttribute("data-bs-theme", next);
      if (next === "dark") {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }
      updateThemeIcons(next);
      try {
        localStorage.setItem("peek-theme", next);
      } catch (err) {
        console.warn("Unable to persist theme preference", err);
      }
    }

    function restoreTheme() {
      const current = document.documentElement.dataset.theme === "dark" ? "dark" : "light";
      updateThemeIcons(current);
    }

    function toggleViewMode() {
      state.viewMode = state.viewMode === "list" ? "card" : "list";
      syncViewToggleState();
      renderItems();
	  
	  try {
        localStorage.setItem("peek-view", state.viewMode);
      } catch (err) {
        console.warn("Unable to persist state preference", err);
      }
	  
    }

    function openDetail(item) {
      if (!item) {
        return;
      }
      const json = JSON.stringify(item, null, 2);
      if (detailJson) {
        detailJson.textContent = json;
      }
      if (!detailDialog) {
        return;
      }
      try {
        detailDialog.showModal();
      } catch (_err) {
        detailDialog.setAttribute("open", "true");
      }
    }

    function closeDetail() {
      if (!detailDialog) {
        return;
      }
      if (typeof detailDialog.close === "function") {
        detailDialog.close();
      } else {
        detailDialog.removeAttribute("open");
      }
    }

    function computeCounts() {
      const counts = new Map();
      state.items.forEach((item) => {
        const slug = item?.config;
        if (!slug) {
          return;
        }
        counts.set(slug, (counts.get(slug) || 0) + 1);
      });
      return counts;
    }

    function toggleConfig(slug) {
      if (selectedSlugs.has(slug)) {
        selectedSlugs.delete(slug);
      } else {
        selectedSlugs.add(slug);
      }
      renderConfigList();
      renderItems();
      updateActiveMeta();
    }

    function getFilteredItems() {
      if (!configs.length || selectedSlugs.size === 0 || selectedSlugs.size === configs.length) {
        return state.items.slice();
      }
      return state.items.filter((item) => selectedSlugs.has(item.config));
    }

    function renderConfigList() {
      if (!configListEl) {
        return;
      }
      configListEl.innerHTML = "";
      if (!configs.length) {
        noConfigsMessage?.classList.remove("hidden");
        return;
      }
      noConfigsMessage?.classList.add("hidden");

      const counts = computeCounts();
      configs.forEach((config) => {
        const isSelected = selectedSlugs.has(config.slug);
        const button = document.createElement("button");
        button.type = "button";
        button.className = `${listGroupBaseClass}${isSelected ? ` ${listGroupActiveClass}` : ""}`;
        button.setAttribute("role", "checkbox");
        button.setAttribute("aria-checked", isSelected ? "true" : "false");
        button.setAttribute("data-slug", config.slug);
        const count = counts.get(config.slug) || 0;
        button.innerHTML = `
          <span class="d-flex flex-column">
            <span class="fw-semibold">${escapeHtml(config.display_name)}</span>
            <span class="text-body-secondary small">${escapeHtml(config.slug)}</span>
          </span>
          <span class="badge text-bg-secondary ms-sm-auto">${count} entr${count === 1 ? "y" : "ies"}</span>
        `;
        button.addEventListener("click", () => {
          toggleConfig(config.slug);
        });
        configListEl.appendChild(button);
      });
    }

    function renderCard(item) {
      const col = document.createElement("div");
      col.className = "col-12 col-md-6 col-xxl-4";
      const card = document.createElement("article");
      card.className = "card h-100 peek-item-card";
      card.tabIndex = 0;
      if (item?.config) {
        card.dataset.config = item.config;
      }

      const dismissButton = document.createElement("button");
      dismissButton.type = "button";
      dismissButton.className = "peek-dismiss-button";
      dismissButton.setAttribute("aria-label", "Dismiss item");
      dismissButton.title = "Dismiss item";
      dismissButton.innerHTML = '<i class="bi bi-x-lg" aria-hidden="true"></i>';
      dismissButton.addEventListener("click", (event) => {
        event.stopPropagation();
        dismissItem(item, { button: dismissButton });
      });
      card.appendChild(dismissButton);

      const highlights = Array.isArray(item?.view?.highlights) ? item.view.highlights : [];
      highlights.forEach((highlight) => {
        card.classList.add(highlight);
      });

      const body = document.createElement("div");
      body.className = "card-body d-flex flex-column gap-3";
	  
	  
	  
	  const metaRow = document.createElement("div");
      metaRow.className = "d-flex flex-wrap align-items-center gap-2";

      const configLabel = document.createElement("span");
      configLabel.className = "badge text-bg-secondary";
      configLabel.textContent = resolveConfigName(item);
      metaRow.appendChild(configLabel);

      const coalesceValue = (item?.coalesce ?? "").toString().trim();
      if (coalesceValue) {
        const coalesceLabel = document.createElement("span");
        coalesceLabel.className = "badge peek-coalesce-badge";
        coalesceLabel.textContent = coalesceValue;
        coalesceLabel.title = `Coalesce: ${coalesceValue}`;
        metaRow.appendChild(coalesceLabel);
      }

	  
	  
	  const timestamp = document.createElement("time");
      timestamp.className = "text-body-secondary small ms-auto";
      timestamp.dateTime = item.ts || "";
      timestamp.textContent = formatTimestamp(item.ts);
      metaRow.appendChild(timestamp);
	  
	  

      body.appendChild(metaRow);
	  
	  
	  //
	  

      const header = document.createElement("div");
      header.className = "d-flex flex-wrap align-items-center gap-2";

      if (item?.view?.badge) {
        const badge = document.createElement("span");
        badge.className = "badge rounded-pill text-bg-info";
        badge.textContent = item.view.badge;
        header.appendChild(badge);
      }

      const title = document.createElement("h3");
      title.className = "h5 mb-0 flex-grow-1";
      title.textContent = item?.view?.title || "Untitled entry";
      header.appendChild(title);

      body.appendChild(header);

      const description = document.createElement("div");
      description.className = "peek-item-description peek-markdown";
      description.innerHTML = renderDescription(item?.view?.description || "");
      if (description.innerHTML.trim()) {
        body.appendChild(description);
      }
	  
	  ///

      const footer = document.createElement("div");
      footer.className = "d-flex justify-content-end";
	  
	  
	  const linkHref = safeHref(item?.view?.link);
      if (linkHref) {
        const link = document.createElement("a");
        link.href = linkHref;
        link.target = "_blank";
        link.rel = "noopener noreferrer";
        link.className = "btn btn-sm btn-outline-primary ms-auto";
        link.textContent = "Open link";
        link.addEventListener("click", (event) => {
          event.stopPropagation();
        });
        footer.appendChild(link);
      }
	  
	  

      const detailButton = document.createElement("button");
      detailButton.type = "button";
      detailButton.className = "btn btn-sm btn-outline-secondary";
      detailButton.textContent = "View details";
      detailButton.addEventListener("click", (event) => {
        event.stopPropagation();
        openDetail(item);
      });
      footer.appendChild(detailButton);
      body.appendChild(footer);

      card.appendChild(body);
      /*card.addEventListener("click", () => {
        openDetail(item);
      });*/
      /*card.addEventListener("keypress", (event) => {
        if (event.target !== card) {
          return;
        }
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          openDetail(item);
        }
      });*/
      col.appendChild(card);
      return col;
    }

    function renderTable(items) {
      const wrapper = document.createElement("div");
      wrapper.className = "table-responsive peek-table-wrapper";
      const table = document.createElement("table");
      table.className = "table table-hover align-middle mb-0 peek-table";
      const thead = document.createElement("thead");
      thead.innerHTML = `
        <tr>
          <th scope="col">Badge</th>
          <th scope="col">Title</th>
          <th scope="col">Description</th>
          <th scope="col">Config</th>
          <th scope="col">Timestamp</th>
          <th scope="col" class="text-end">Actions</th>
        </tr>
      `;
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      items.forEach((item) => {
        const tr = document.createElement("tr");
        tr.className = "peek-table-row";
        tr.tabIndex = 0;
        if (item?.config) {
          tr.dataset.config = item.config;
        }
        const highlights = Array.isArray(item?.view?.highlights) ? item.view.highlights : [];
        highlights.forEach((highlight) => {
          tr.classList.add(highlight);
        });

        const badgeCell = document.createElement("td");
        badgeCell.textContent = item?.view?.badge || "—";

        const titleCell = document.createElement("td");
        titleCell.textContent = item?.view?.title || "Untitled entry";

        const descriptionCell = document.createElement("td");
        descriptionCell.className = "peek-markdown";
        descriptionCell.innerHTML = renderDescription(item?.view?.description || "");

        const configCell = document.createElement("td");
        const configWrapper = document.createElement("span");
        configWrapper.className = "d-inline-flex align-items-center gap-2 flex-wrap";

        const configName = document.createElement("span");
        configName.textContent = resolveConfigName(item) || "—";
        configWrapper.appendChild(configName);

        const coalesceValue = (item?.coalesce ?? "").toString().trim();
        if (coalesceValue) {
          const coalesceBadge = document.createElement("span");
          coalesceBadge.className = "badge peek-coalesce-badge";
          coalesceBadge.textContent = coalesceValue;
          coalesceBadge.title = `Coalesce: ${coalesceValue}`;
          configWrapper.appendChild(coalesceBadge);
        }

        configCell.appendChild(configWrapper);

        const timestampCell = document.createElement("td");
        timestampCell.textContent = formatTimestamp(item.ts);

        const actionCell = document.createElement("td");
        actionCell.className = "text-end";
        const actionWrapper = document.createElement("div");
        actionWrapper.className = "d-inline-flex gap-2";

        const actionButton = document.createElement("button");
        actionButton.type = "button";
        actionButton.className = "btn btn-sm btn-outline-secondary";
        actionButton.textContent = "View";
        actionButton.addEventListener("click", (event) => {
          event.stopPropagation();
          openDetail(item);
        });
        actionWrapper.appendChild(actionButton);

        const dismissButton = document.createElement("button");
        dismissButton.type = "button";
        dismissButton.className = "btn btn-sm btn-outline-danger";
        dismissButton.title = "Dismiss item";
        dismissButton.innerHTML = '<i class="bi bi-x-lg" aria-hidden="true"></i><span class="visually-hidden">Dismiss</span>';
        dismissButton.addEventListener("click", (event) => {
          event.stopPropagation();
          dismissItem(item, { button: dismissButton });
        });
        actionWrapper.appendChild(dismissButton);

        actionCell.appendChild(actionWrapper);

        tr.appendChild(badgeCell);
        tr.appendChild(titleCell);
        tr.appendChild(descriptionCell);
        tr.appendChild(configCell);
        tr.appendChild(timestampCell);
        tr.appendChild(actionCell);
        tr.addEventListener("click", () => {
          openDetail(item);
        });
        tr.addEventListener("keypress", (event) => {
          if (event.target !== tr) {
            return;
          }
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            openDetail(item);
          }
        });
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      wrapper.appendChild(table);
      return wrapper;
    }

    function renderItems() {
      visibleItems = getFilteredItems();
      if (!itemsContainer) {
        return;
      }
      itemsContainer.innerHTML = "";
      itemsContainer.dataset.viewMode = state.viewMode;

      if (!state.initialized) {
        emptyStateEl?.classList.add("hidden");
        itemsCountBadge?.setAttribute("hidden", "true");
        return;
      }

      if (!visibleItems.length) {
        if (!configs.length) {
          emptyStateMessageEl && (emptyStateMessageEl.textContent = "Add a configuration to begin ingesting data.");
        } else if (selectedSlugs.size > 0 && state.items.length) {
          emptyStateMessageEl && (emptyStateMessageEl.textContent = "No entries match the selected configurations yet.");
        } else {
          emptyStateMessageEl && (emptyStateMessageEl.textContent = "New items will appear here automatically.");
        }
        emptyStateEl?.classList.remove("hidden");
        itemsCountBadge?.setAttribute("hidden", "true");
        return;
      }

      emptyStateEl?.classList.add("hidden");
      itemsCountBadge?.removeAttribute("hidden");
      if (itemsCountBadge) {
        itemsCountBadge.textContent = `${visibleItems.length} item${visibleItems.length === 1 ? "" : "s"}`;
      }

      if (state.viewMode === "card") {
        const row = document.createElement("div");
        row.className = "row g-3";
        visibleItems.forEach((item) => {
          row.appendChild(renderCard(item));
        });
        itemsContainer.appendChild(row);
        return;
      }

      itemsContainer.appendChild(renderTable(visibleItems));
    }

    function updateActiveMeta() {
      if (!activeConfigTitle || !activeConfigSubtitle) {
        return;
      }
      if (!configs.length) {
        activeConfigTitle.textContent = "Awaiting configurations";
        activeConfigSubtitle.textContent = "Add a configuration file to begin streaming updates.";
        return;
      }
      if (selectedSlugs.size === 0 || selectedSlugs.size === configs.length) {
        activeConfigTitle.textContent = "All configurations";
        activeConfigSubtitle.textContent = "Showing the latest entries across every configuration.";
        return;
      }
      const selectedConfigs = configs.filter((config) => selectedSlugs.has(config.slug));
      const names = selectedConfigs.map((config) => config.display_name);
      activeConfigTitle.textContent = names.join(", ") || "Filtered view";
      activeConfigSubtitle.textContent = `Showing ${visibleItems.length} entr${visibleItems.length === 1 ? "y" : "ies"} from ${selectedConfigs.length} configuration${selectedConfigs.length === 1 ? "" : "s"}.`;
    }

    function updateLoadingState(items) {
      state.items = items;
      state.items.sort((a, b) => (a.ts < b.ts ? 1 : -1));
      while (state.items.length > 500) {
        const removed = state.items.pop();
        if (removed && removed.id) {
          itemById.delete(removed.id);
        }
      }
      state.initialized = true;
    }

    function dismissItem(item, { button = null } = {}) {
      if (!item || !item.id || !item.config) {
        return;
      }
      const key = `${item.config}:${item.id}`;
      if (pendingDismissals.has(key)) {
        return;
      }
      pendingDismissals.add(key);
      if (button) {
        button.disabled = true;
        button.setAttribute("aria-busy", "true");
      }
      fetch(`/api/${encodeURIComponent(item.config)}/${encodeURIComponent(item.id)}`, { method: "DELETE" })
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Failed to dismiss item: ${response.status}`);
          }
          const changed = applyItemEvent({
            id: item.id,
            config: item.config,
            event: "deleted",
          });
          if (changed) {
            renderConfigList();
            renderItems();
            updateActiveMeta();
          }
        })
        .catch((err) => {
          console.error(err);
        })
        .finally(() => {
          pendingDismissals.delete(key);
          if (button) {
            button.disabled = false;
            button.removeAttribute("aria-busy");
          }
        });
    }

    function fetchItems({ append = false, cursorOverride = null } = {}) {
      if (state.fetching) {
        return;
      }
      const cursorToUse = cursorOverride ?? (append ? state.nextCursor : null);
      if (append && !cursorToUse) {
        return;
      }
      state.fetching = true;
      updateLoading(true);

      const params = new URLSearchParams({ limit: "50" });
      if (cursorToUse) {
        params.set("cursor", cursorToUse);
      }

      fetch(`/api/items?${params.toString()}`)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Failed to load items: ${response.status}`);
          }
          return response.json();
        })
        .then((payload) => {
          const items = Array.isArray(payload.items) ? payload.items : [];
          items.forEach((item) => {
            if (!item || !item.id) {
              return;
            }
            itemById.set(item.id, item);
          });
          const nextItems = Array.from(itemById.values());
          updateLoadingState(nextItems);
          state.nextCursor = payload.next_cursor || null;
          renderConfigList();
          renderItems();
        })
        .catch((err) => {
          console.error(err);
        })
        .finally(() => {
          state.fetching = false;
          updateLoading(false);
          updateActiveMeta();
        });
    }

    function applyItemEvent(item) {
      if (!item || !item.id) {
        return false;
      }
      if (item.event === "deleted" || item.deleted === true) {
        const removed = itemById.delete(item.id);
        if (!removed) {
          return false;
        }
        const nextItems = Array.from(itemById.values());
        updateLoadingState(nextItems);
        return true;
      }
      itemById.set(item.id, item);
      const nextItems = Array.from(itemById.values());
      updateLoadingState(nextItems);
      return true;
    }

    function connectStream() {
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      try {
        eventSource = new EventSource("/api/stream");
      } catch (err) {
        console.error("Failed to connect to stream", err);
        return;
      }
      eventSource.addEventListener("message", (event) => {
        try {
          const item = JSON.parse(event.data);
          const changed = applyItemEvent(item);
          if (changed) {
            renderConfigList();
            renderItems();
            updateActiveMeta();
          }
        } catch (err) {
          console.error("Unable to parse stream payload", err);
        }
      });
      eventSource.addEventListener("error", () => {
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
        reconnectTimeout = window.setTimeout(() => {
          connectStream();
        }, 3000);
      });
    }

    if (viewToggle) {
      viewToggle.addEventListener("click", () => {
        toggleViewMode();
      });
    }
    if (themeToggle) {
      themeToggle.addEventListener("click", () => {
        toggleTheme();
      });
      restoreTheme();
    }
    if (closeDialog) {
      closeDialog.addEventListener("click", () => {
        closeDetail();
      });
    }
    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        closeDetail();
      }
    });

    const observer = "IntersectionObserver" in window
      ? new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            fetchItems({ append: true });
          }
        });
      }, { rootMargin: "200px" })
      : null;

    if (observer && loadMoreSentinel) {
      observer.observe(loadMoreSentinel);
    }

    renderConfigList();
    renderItems();
    updateActiveMeta();
    syncViewToggleState();
    fetchItems();
    connectStream();

    window.addEventListener("beforeunload", () => {
      if (eventSource) {
        eventSource.close();
      }
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
      }
    });
  </script>
</body>
</html>
